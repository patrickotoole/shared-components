
<meta charset="utf-8">
<style type="text/css">

text {
    font-size: 11px;
      pointer-events: none;
}

text.parent {
    fill: #1f77b4;
}

circle {
    fill: #ccc;
      stroke: #999;
        pointer-events: all;
}

circle.parent {
    fill: #1f77b4;
      fill-opacity: .1;
        stroke: steelblue;
}

circle.parent:hover {
    stroke: #ff7f0e;
      stroke-width: .5px;
}

circle.child {
    pointer-events: none;
}

</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="/static/js/rockerbox/dataobjects.js"></script>
<script type="text/javascript">

var w = 1280,
    h = 800,
    r = 720,
    x = d3.scale.linear().range([0, r]),
    y = d3.scale.linear().range([0, r]),
    node,
    root;

var pack = d3.layout.pack()
    .size([r, r])
    .value(function(d) { return d.count + .2; })

var vis = d3.select("body").append("svg")
    .attr("width", w)
    .attr("height", h)
  .append("svg:g")
    .attr("transform", "translate(" + (w - r) / 2 + "," + (h - r) / 2 + ")");






var currentZoom;

var codify = function(node) {
  var s = node.pattern + node.label
  if (node.segment)
    s += node.segment.id + node.segment.value + node.segment.duration
  if (node.queue)
    s += node.queue.id
  return s
}

var recursive = function(node) {

  node.merkle = (node.children && node.children.length > 0) ? 
    JSON.stringify(codify(node.node)) + node.children.sort(function(x,y){return x.node.pattern + x.node.label > y.node.pattern + y.node.label }).map(recursive).join(",") : 
    JSON.stringify(codify(node.node))

  return node.merkle

}


var build = function(data) {
  if (currentZoom === undefined) currentZoom = data;     

  recursive(data)
  node = root = data;

  var nodes = pack.nodes(root);
  window.nodes = nodes


  circles = vis.selectAll("circle")
      .data(nodes,function(f,i){ return f.merkle})

  circles
    .enter().append("svg:circle")

  var text = vis.selectAll("text")
      .data(nodes,function(f,i){ return f.merkle})

  text
    .enter().append("svg:text")

  var tspan = text.selectAll('tspan')
      .data(function(d){
        return [
          {r: d.r, x: d.x, value: d.node.pattern, merkle: d.merkle, type: "pattern"}, 
          {r: d.r, x: d.x, value: d.node.label, merkle: d.merkle, type: "label"}, 
          {r: d.r, x: d.x, value: (d.node.segment || d.node.queue) ? d.count : "", merkle: d.merkle, type: "segment"}
        ]
      }, function(i){ return i.merkle + i.type})

  tspan
      .enter()
      .append('svg:tspan')


  var load = function() {
    var v = vis

    v.selectAll("circle")
      .attr("class", function(d) { return d.children ? "parent" : "child"; })
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; })
      .attr("r", function(d) { return d.r; })
      .attr("id",function(d) {  return d.node.pattern; })

    vis.selectAll("circle")
      .on("click", function(d) { return zoom(node == d ? root : d); });

    var text = vis.selectAll("text")

    text
      .attr("class", function(d) { return d.children ? "parent" : "child"; })
      .attr("x", function(d) { return d.x; })
      .attr("y", function(d) { return d.y - ((d.node.segment || d.node.queue) ? 0 : 10); })
      .attr("dy", ".35em")
      .attr("text-anchor", "middle")
      .style("opacity", function(d) { return d.r > 20 ? 1 : 0; })
 
    tspan
      .attr("x", function(d) { return d.x; })
      .attr("dy", "1.2em")
      .text(function(d) { return d.value; })
  }

  if (currentZoom == root) load()
  else zoom(currentZoom,1)

  d3.select(window).on("click", function() { zoom(root); });

function zoom(d, new_data) {

  currentZoom = d

  var asMap = d3.nest().key(function(x){return x.merkle}).map(nodes)

  var or = d.r,
    ok = r / d.r / 2;
  debugger;

  var dr = new_data ? asMap[d.merkle][0].r : d.r,
    dx = new_data ? asMap[d.merkle][0].x : d.x,
    dy = new_data ? asMap[d.merkle][0].y : d.y

  var k = r / dr / 2;
  x.domain([dx - dr, dx + dr]);
  y.domain([dy - dr, dy + dr]);  

  /*
  var k = r / d.r / 2;
  x.domain([d.x - d.r, d.x + d.r]);
  y.domain([d.y - d.r, d.y + d.r]);

  console.log(d.r,asMap[d.merkle][0].r)
  console.log(d.x,asMap[d.merkle][0].x)
  console.log(d.y,asMap[d.merkle][0].y)
  */

  t = vis.transition()
      .duration(d3.event && d3.event.altKey ? 7500 : 750);

  t.selectAll("circle")
      .attr("cx", function(d) { return x(d.x); })
      .attr("cy", function(d) { return y(d.y); })
      .attr("r", function(d) { return k * d.r; });

  var text = t.selectAll("text")
      .attr("x", function(d) { return x(d.x); })
      .attr("y", function(d) { return y(d.y - ((d.node.segment || d.node.queue) ? 0 : 10)); })
      .style("opacity", function(d) { return k * d.r > 20 ? 1 : 0; });


  t.selectAll("text").selectAll("tspan")
      .attr("x", function(d) { return x(d.x); })
      .style("opacity", function(d) { 
        //console.log(or, dr, ok, k, d.r, asMap[d.merkle][0].r, k*d.r, k*asMap[d.merkle][0].r); 
        return k*d.r > 20 ? 1 : 0; 
      })
      .text(function(d) { return d.value; });

  node = d;
  if (d3.event) d3.event.stopPropagation();
}

}


RB.websocket.addSubscription("treefilter",{"name":"treefilter","values":false},{"name":"treefilter","callback":function(x){
    x.treefilter.filter(function(y){ 
      return y.count
    }).map(function(x){
      build(x)
    })
  }
})

RB.websocket.connect()
RB.websocket.add_on_connected(function(){
  RB.websocket.subscribe()
})



    </script>
